---
## Author
author:
  name: Иванова Ангелина Олеговна
  degrees: DSc
  orcid: 0000-0002-0877-7063
  email: kulyabov-ds@rudn.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Лабораторная работа №9"
subtitle: "НПИбд-01-25 №1032252598"
license: "CC BY"
---

# Цель работы

Целью данной лабораторной работы является приобретение навыков написания программ с использованием подпрограмм и знакомство с методами отладки при помощи GDB и его основными возможностями.

# Выполнение лабораторной работы

## Задания лабораторной работы

### Реализация подпрограмм в NASM

Создали каталог для выполнения лабораторной работы № 9, перешли в него и создали файл lab09-1.asm  
<figure>
![Создание каталога и файла](image/1.png "Создание каталога и файла"){#fig-001 width=90%}
</figure>

Внимательно изучили текст программы первого листинга. Ввели в файл lab09-1.asm текст программы из первого листинга.

<figure>
![Измененный файл lab09-1.asm](image/2.png "Измененный файл lab09-1.asm"){#fig-001 width=90%}
</figure>

Создали исполняемый файл и запустили его. Получили корректный результат работы данной программы

<figure>
![Создание исполняемого файла и вывод его работы](image/3.png "Создание исполняемого файла и вывод его работы"){#fig-001 width=90%}
</figure>

Далее изменили программу, добавив подпрограмму _subcalcul в подпрограмму _calcul, для вычисления выражения f(g(x)), где x вводится с клавиатуры, f(x) = 2x + 7, g(x) = 3x − 1. Т.е. x передается в подпрограмму _calcul из нее в подпрограмму _subcalcul, где вычисляется выражение g(x), результат возвращается в _calcul и вычисляется выражение f(g(x)). Результат возвращается в основную программу для вывода результата на экран.

**Листинг 1:**    
%include 'in_out.asm'  
SECTION .data  
msg: DB 'Введите x: ',0  
result: DB 'f(g(x))=2*(3x-1)+7=',0  
SECTION .bss  
x: RESB 80  
res: RESB 80  
SECTION .text  
GLOBAL _start  
_start:  
;------------------------------------------  
; Основная программа  
;------------------------------------------  
mov eax, msg  
call sprint  
mov ecx, x  
mov edx, 80  
call sread  
mov eax, x  
call atoi  
call _calcul  
mov eax, result  
call sprint  
mov eax, [res]  
call iprintLF  
call quit  
;------------------------------------------  
; Подпрограмма вычисления f(g(x))  
;------------------------------------------  
_calcul:  
    push ebx  
    call _subcalcul  
    mov ebx, 2  
    mul ebx  
    add eax, 7  
    mov [res], eax  
    pop ebx  
    ret  
_subcalcul:  
    push ebx  
    mov ebx, 3  
    mul ebx  
    sub eax, 1  
    pop ebx  
    ret  
       
<figure>
![Измененный текст программы](image/4.png "Измененный текст программы"){#fig-001 width=90%}
</figure>

Создали исполняемый файл и проверили его работу

<figure>
![Создание исполняемого файла и вывод его работы](image/5.png "Создание исполняемого файла и вывод его работы"){#fig-001 width=90%}
</figure>

### Отладка программам с помощью GDB

Создали файл lab09-2.asm и ввели в него текст программы из второго листинга

<figure>
![Измененный файл lab09-2.asm](image/6.png "Измененный файл lab09-2.asm"){#fig-001 width=90%}
</figure>

Создали исполняемый файл. Для работы с GDB в исполняемый файл добавили отладочную информацию, для этого трансляцию программ провели с ключом ‘-g’. Загрузили исполняемый файл в отладчик gdb и проверили работу программы, запустив ее в оболочке GDB с помощью команды run

<figure>
![Создание исполняемого файла и проверка его работы в оболочке GDB](image/7.png "Создание исполняемого файла и проверка его работы в оболочке GDB"){#fig-001 width=90%}
</figure>

Для более подробного анализа программы установили брейкпоинт на метку _start, с которой начинается выполнение любой ассемблерной программы, и запустили её.

<figure>
![Добавление брейкпоинта и запуск программы](image/8.png "Добавление брейкпоинта и запуск программы"){#fig-001 width=90%}
</figure>

Посмотрили дисассимилированный код программы с помощью команды disassemble начиная с метки _start

<figure>
![Просмотр дисассимилированного кода программы](image/9.png "Просмотр дисассимилированного кода программы"){#fig-001 width=90%}
</figure>

Переключились на отображение команд с Intel’овским синтаксисом, введя команду set disassembly-flavor intel

<figure>
![Переключение и просмотр дисассимилированного кода программы](image/10.png "Переключение и просмотр дисассимилированного кода программы"){#fig-001 width=90%}
</figure>

Различия отображения синтаксиса машинных команд в режимах ATT и Intel:  
1.Порядок операндов: В ATT синтаксисе порядок операндов обратный, сначала указывается исходный операнд, а затем - результирующий операнд. В Intel синтаксисе порядок обычно прямой, результирующий операнд указывается первым, а исходный - вторым.  
2.Разделители: В ATT синтаксисе разделители операндов - запятые. В Intel синтаксисе разделители могут быть запятые или косые черты (/).  
3.Префиксы размера операндов: В ATT синтаксисе размер операнда указывается перед операндом с использованием префиксов, таких как “b” (byte), “w” (word), “l” (long) и “q” (quadword). В Intel синтаксисе размер операнда указывается после операнда с использованием суффиксов, таких как “b”, “w”, “d” и “q”.  
4.Знак операндов: В ATT синтаксисе операнды с позитивными значениями предваряются символом “". "”.  
5.Обозначение адресов: В ATT синтаксисе адреса указываются в круглых скобках. В Intel синтаксисе адреса указываются без скобок.  
6.Обозначение регистров: В ATT синтаксисе обозначение регистра начинается с символа “%”. В Intel синтаксисе обозначение регистра может начинаться с символа “R” или “E” (например, “%eax” или “RAX”).  

Включили режим псевдографики для более удобного анализа программы

<figure>
![Включение режима псевдографики](image/11.png "Включение режима псевдографики"){#fig-001 width=90%}
</figure>


### Добавление точек останова

На предыдущих шагах была установлена точка останова по имени метки (_start). Проверили это с помощью команды info breakpoints

<figure>
![Проверка меток](image/12.png "Проверка меток"){#fig-001 width=90%}
</figure> 

Определили адрес предпоследней инструкции (mov ebx,0x0) и установили точку останова. Посмотрели информацию о всех установленных точках останова

<figure>
![Установка точки остонова и просмотр информации](image/13.png "Установка точки остонова и просмотр информации"){#fig-001 width=90%}
</figure>

### Работа с данными программы в GDB

Выполнили 5 инструкций с помощью команды stepi (или si) и проследили за изменением значений регистров. Итого, за 5 инструкций регистры изменялись следующим образом:  
1. eax = 4  
2. ebx = 1  
3. ecx = 134520832  
4. edx = 8  
5. eax = 8  

<figure>
![Выполнение 1 инструкции](image/14.png "Выполнение 1 инструкции"){#fig-001 width=90%}
</figure>

<figure>
![Выполнение 2 инструкции](image/15.png "Выполнение 2 инструкции"){#fig-001 width=90%}
</figure>

<figure>
![Выполнение 3 инструкции](image/16.png "Выполнение 3 инструкции"){#fig-001 width=90%}
</figure>

<figure>
![Выполнение 4 инструкции](image/17.png "Выполнение 4 инструкции"){#fig-001 width=90%}
</figure>

<figure>
![Выполнение 5 инструкции](image/18.png "Выполнение 5 инструкции"){#fig-001 width=90%}
</figure>

Посмотрели содержимое регистров с помощью команды info registers

<figure>
![Использование команды info registers](image/19.png "Использование команды info registers"){#fig-001 width=90%}
</figure>

Посмотрели значение переменной msg1 по имени и посмотрели значение переменной msg2 по адресу

<figure>
![Просмотр значения переменных msg1 и msg2](image/20.png "Просмотр значения переменных msg1 и msg2"){#fig-001 width=90%}
</figure>

Изменили первый символ переменной msg1

<figure>
![Изменение первого символа переменной msg1](image/21.png "Изменение первого символа переменной msg1"){#fig-001 width=90%}
</figure>

Заменили первый символ во второй переменной msg2

<figure>
![Изменение первого символа переменной msg2](image/22.png "Изменение первого символа переменной msg2"){#fig-001 width=90%}
</figure>

Вывели в различных форматах (в шестнадцатеричном формате, в двоичном формате и в символьном виде) значение регистра edx.

<figure>
![Выведение регистра в разных форматах](image/23.png "Выведение регистра в разных форматах"){#fig-001 width=90%}
</figure>

С помощью команды set измените значение регистра ebx

<figure>
![Изменение регистра](image/24.png "Изменение регистра"){#fig-001 width=90%}
</figure>

Разница вывода заключается в том, что '2' интерпретируется как ASCII-код, а 2 как обычное число.  
set $ebx='2' - '2' это символ, его ASCII-код 50, поэтому 'p/s $ebx' выводит число 50    
set $ebx=2 — просто число 2, 'p/s $ebx' выводит 2.    

Завершили выполнение программы с помощью команды continue (сокращенно c) и вышли из GDB с помощью команды quit (сокращенно q).

### Обработка аргументов командной строки в GDB

Скопировали файл lab8-2.asm, созданный при выполнении лабораторной работы №8, с программой выводящей на экран аргументы командной строки в файл с именем lab09-3.asm. Создали исполняемый файл.

<figure>
![Копирование и создание исполняемого файла](image/25.png "Копирование и создание исполняемого файла"){#fig-001 width=90%}
</figure>

Загрузите исполняемый файл в отладчик, указав аргументы. Для начала установили точку останова перед первой инструкцией в программе и запустили ее.

<figure>
![Загрузка в отладчик, установка точки остонова и запуск](image/26.png "Загрузка в отладчик, установка точки остонова и запуск"){#fig-001 width=90%}
</figure>

Адрес вершины стека храниться в регистре esp и по этому адресу располагается число равное количеству аргументов командной строки. Посмотрели остальные позиции стека – по адесу [esp+4] располагается адрес в памяти где находиться имя программы, по адесу [esp+8] храниться адрес первого аргумента, по аресу [esp+12] – второго и т.д.

<figure>
![Вывод позиций стека](image/27.png "Вывод позиций стека"){#fig-001 width=90%}
</figure>

Шаг изменения адреса равен 4 потому что адресные регистры имеют размер-
ность 32 бита(4 байта).

## Задание для самостоятельной работы

1. Преобразовали программу из лабораторной работы №8 (Задание №1 для самостоятельной работы), реализовав вычисление значения функции f(x) как подпрограмму.

**Листинг 2**   
    
%include 'in_out.asm'  
  
SECTION .data  
    msg db "Результат: ", 0  
      
SECTION .bss  
    res: RESB 80  
      
SECTION .text  
    global _start  
      
_start:  
    pop ecx  
    pop edx  
    sub ecx, 1  
    mov dword [res], 0  
  
next:  
    cmp ecx, 0h  
    jz _end  
    pop eax  
    call atoi  
    call _calcul  
    add [res], eax  
    dec ecx  
    jmp next  
  
_end:  
    mov eax, msg  
    call sprint  
    mov eax, [res]  
    call iprintLF  
    call quit  
  
_calcul:  
    mov ebx, 8  
    mul ebx  
    sub eax, 3  
    ret  
    
<figure>
![Работа созданного нами файла](image/28.png "Работа созданного нами файла"){#fig-001 width=90%}
</figure> 

2. В третьем листинге приведена программа вычисления выражения $(3+2)∗4+5$. При запуске данная программа дает неверный результат.

<figure>
![Неверный результат работы программы](image/29.png "Неверный результат работы программы"){#fig-001 width=90%}
</figure> 

С помощью отладчика GDB, анализируя изменения значений регистров, определили ошибку

<figure>
![Поиск ошибки](image/30.png "Поиск ошибки"){#fig-001 width=90%}
</figure> 

Исправили ошибку в программе.

**Листинг 3**     
%include 'in_out.asm'  
SECTION .data  
div: DB 'Результат: ',0  
SECTION .text  
GLOBAL _start  
_start:  
; ---- Вычисление выражения (3+2)*4+5  
mov ebx,3  
mov eax,2  
add eax,ebx  
mov ecx,4  
mul ecx  
add eax,5  
mov edi,eax  
; ---- Вывод результата на экран  
mov eax,div  
call sprint  
mov eax,edi  
call iprintLF  
call quit  

Создали исполняемый файл и проверили корректность выполнения программы
<figure>
![Работа созданного нами файла](image/31.png "Работа созданного нами файла"){#fig-001 width=90%}
</figure> 

# Выводы

Приобрели навыки написания программ с использованием подпрограмм и познакомились с методами отладки при помощи GDB и его основными возможностями.

::: {#refs}
:::
